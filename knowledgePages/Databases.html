<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div id='header'></div>
    <div id='first'>
        <h3>Индексы</h3>
        <p>
            Индекс ускоряет процесс запроса, предоставляя быстрый доступ к строкам данных в таблице
            , аналогично тому, как указатель в книге помогает вам быстро найти необходимую информацию.
        </p>
        <p>
            Индексы создаются для столбцов таблиц и представлений. Индексы предоставляют путь для быстрого поиска данных на основе значений в этих столбцах.
             Например, если вы создадите индекс по первичному ключу, а затем будете искать строку с данными, используя значения первичного ключа, то SQL Server
              сначала найдет значение индекса, а затем использует индекс для быстрого нахождения всей строки с данными. Без индекса будет выполнен полный
               просмотр (сканирование) всех строк таблицы, что может оказать значительное влияние на производительность.
        </p>
        <h3>Кластеризованный индекс</h3>
        <p>
            Кластеризованный индекс хранит реальные строки данных в листьях индекса. Возвращаясь к предыдущему примеру, это означает что строка данных,
             связанная со значение ключа, равного 123 будет храниться в самом индексе. Важной характеристикой кластеризованного индекса является то, что
              все значения отсортированы в определенном порядке либо возрастания, либо убывания. Таким образом, таблица или представление может иметь только
               один кластеризованный индекс. В дополнение следует отметить, что данные в таблице хранятся в отсортированном виде только в случае если создан 
               кластеризованный индекс у этой таблицы.
            Таблица не имеющая кластеризованного индекса называется кучей.
        </p>
        <h3>
            Некластеризованный индекс
        </h3>
        <p>
            В отличие от кластеризованного индекса, листья некластеризованного индекса содержат только те столбцы (ключевые), по которым определен данный индекс,
             а также содержит указатель на строки с реальными данными в таблице. Это означает, что системе подзапросов необходима дополнительная операция для обнаружения
              и получения требуемых данных. Содержание указателя на данные зависит от способа хранения данных: кластеризованная таблица или куча. Если указатель ссылается
               на кластеризованную таблицу, то он ведет к кластеризованному индексу, используя который можно найти реальные данные. Если указатель ссылается на кучу, то он
                ведет к конкретному идентификатору строки с данными. Некластеризованные индексы не могут быть отсортированы в отличие от кластеризованных, однако вы можете
                 создать более одного некластеризованного индекса на таблице или представлении, вплоть до 999. Это не означает, что вы должны создавать как можно больше
                  индексов. Индексы могут как улучшить, так и ухудшить производительность системы. В дополнение к возможности создать несколько некластеризованных индексов
                  , вы можете также включить дополнительные столбцы (included column) в свой индекс: на листьях индекса будет храниться не только значение самих
                   индексированных столбцов, но и значения этих не индексированных дополнительных столбцов. Этот подход позволит вам обойти некоторые ограничения,
                    наложенные на индекс. К примеру, вы можете включить неидексируемый столбец или обойти ограничение на длину индекса (900 байт в большинстве случаев).
        </p>
        <p>
            Продолжение: <a href = 'https://habr.com/ru/post/247373/'>14 вопросов об индексах в SQL Server, которые вы стеснялись задать</a>
        </p>
    </div id = 'second'>
    <h3>
        CAP-теорема
    </h3>
    <p>
        Итак, давайте теперь взглянем на CAP-теорему. Утверждается, что при разработке распределённой системы вы не можете достичь одновременно трёх свойств:
         доступность, согласованность и терпимость к разделению сети. Вы можете выбрать только два из:
    Согласованность (Consistency) — Ваши клиенты единожды обновив информацию всегда могут получить самые актуальные данные при их последующем запросе. И не важно, насколько быстро они вам перезвонят.
    Доступность (Availability) — «Позвони, напомню» всегда доступна для звонков в тот момент, когда хотя бы один из сотрудников вышел на работу.
    Терпимость к разделению сети. (Partition Tolerance) «Позвони, напомню» всегда работает корректно, даже если вы потеряли связь с вашей женой.
    </p>
    <p>
        <a href='https://habr.com/ru/post/130577/'>CAP-теорема простым, доступным языком</a>
    </p>
    <div id='third'>
        <h3></h3>
        <p>
            <a href='https://habr.com/ru/post/254773/'>Нормализация отношений. Шесть нормальных форм</a>
        </p>
    </div>
    <div id='fourth'>
        <h3>
            Уровни изолированности транзакций
        </h3>
        <p>
            <a href='https://habr.com/ru/post/469415/'>Уровни изолированности транзакций для самых маленьких</a>
        </p>
    </div>
</body>
</html>